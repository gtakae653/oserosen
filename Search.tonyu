/*
分岐器の向きまで考慮する？
*/

//direction　下り　1　上り　0
function searchNextStation(stationName,direction){
    var station=$stations[stationName];//駅名から駅情報を取り出す
    var nextst = station.nexts;//次の駅名
    f=nextst.filter(isLineOf);//fはindexOfで判定した駅の配列
    nextlength = f.length;//次の駅の総数
    
    //f[2]が存在する場合(次の駅が３つ以上ある場合)
    if(nextlength < 3){
        a = isTerminal(stationName);
        if(a==0){//終点ではないなら
            return f[direction];
        }else if(a==1 && direction==1){//上りの終点かつ出力方向が下りなら
            return f[0];//次の駅を返す
        }else if(a==1 && direction==0){//上りの終点かつ出力方向が上りなら
            return null;
        }else if(a==2 && direction==1){//下りの終点かつ出力方向が下りなら
            return null;
        }else{//下りの終点かつ出力方向が上りなら
            return f[0];//次の駅を返す
        }
    }else{
        /*　考え中
        f[2]の駅(両国)を起点に考えたとき、３方向分岐駅(錦糸町)の隣駅(亀戸)が、
        ３方向分岐駅から見た時上りにあるか下りにあるかを調べることで、
        f[2]が３方向分岐駅から見て上りにあるか下りにあるかを判断する
        
        例外は？
        */
        return f[2];
    }
}

/*導入すべき処理？
if(方面の違う && 既出ではない駅(f[2]など)があるならば){
    その駅(支線の駅を想定)を出力する
}
*/

function isLineOf(stationName){//駅名がlineNameかを判定する関数
    var station=$stations[stationName];//駅名から駅情報を取り出す
    var line = station.lines;//↑のstationの中のlinesの情報をlineに格納
    if(line.indexOf(lineName) > -1){
        return true;
    }else{
        return false;
    }
}

function isTerminal(stationName){//次の駅が１駅しか無いことを利用した終点の判定
    var station=$stations[stationName];//駅名から駅情報を取り出す
    var nextst = station.nexts;//次の駅名
    f=nextst.filter(isLineOf);//fはindexOfで判定した駅の配列
    
    if(f.length == 1){//終点の場合(nextsに１つしかない場合)
        var ns = $stations[f[0]];
        n = ns.nexts;
        m=n.filter(isLineOf);//mは終点の次の駅のnextsを路線でfilterした後の配列
        
        if(stationName == m[0]){
            return 1;//上り終点
        }else if(stationName == m[1]){
            return 2;//下り終点
        }else{
            //起こり得ないはず
            //西船橋を京葉線の支線部終点として扱うなら...？nexts[市川塩浜、南船橋]
        }
    }else{
        return 0;//終点ではない
    }
}

function searchOwner(stationName){//stationNameのownerを調べる
    if($owner[stationName]){
        var staown = $owner[stationName];
        var owner = staown.owner;
        //print(owner);
        return owner;
    }
}

function updateOwner(startStation,endStation,direction){
    while(true){
        var st = searchNextStation(startStation,direction);
        if(st == endStation){
            break;
        }
        if(! $owner[st]){
            $owner[st]={owner:0};
        }
        $owner[st].owner = $turn;
        startStation = st;
    }
}

s = stationName;//Mainから渡された駅名
so = (searchOwner(stationName));
print("");

for(i=0;i<500;i++){//上り方面用
    end = isTerminal(stationName);
    if(end == 1){//上り終点なら
        break;
    }
    
    //print(isTerminal(stationName));//終点駅の方向確認
    sta = (searchNextStation(stationName,0));
    //print(sta);
    a = (searchOwner(sta));
    if(a == so){
        o = (updateOwner(s,sta,0));
        break;
    }
    stationName = sta;
}

/*上り方面の挟む駅*/
//起点駅　s　　終端駅　sta

print("");
stationName = s;//上り方面の処理でstationNameを上書きされてしまうため

for(i=0;i<500;i++){//下り方面用
    end = isTerminal(stationName);
    if(end == 2){//下り終点なら
        break;
    }
    //print(isTerminal(stationName));//終点駅の方向確認
    sta = (searchNextStation(stationName,1));
    //print(sta);
    a = (searchOwner(sta));
    if(a == so){
        o = (updateOwner(s,sta,1));
        break;
    }
    stationName = sta;
}



fireEvent("complete");
