"field strict";
var path:Path;
var from:Node,lineName:Node,owner:Number;
//fromは本当に最初の駅(ボタンを押した駅)
var current;
var prevNode;
var keep;

path.add(current);
while(true) {
    if (from.name != current.name && $owner[current.name] && $owner[current.name].owner === owner) {
        report([path]);
        break;
    }
    x=current.x;
    y=current.y;
    var neighbors=[];
    for (var neighbor of current.allConnected(lineName)) {
        if (path.contains(neighbor)) continue;
        neighbors.push(neighbor);
    }
    if (neighbors.length==0) {//nextsが１つしかない場合
        path.die();
        report([]);
    } else if (neighbors.length==1) {//nextsが２つの場合
        current=neighbors[0];
        path.add(current);
    } else {//nextsが３つ以上の場合
        
        /*
        print(current.name);
        print($stations[current.name].nexts,prevNode);
        */
        if(prevNode){
            if($stations[current.name].nexts.indexOf(prevNode) == 1){
                print(neighbors[0].name,neighbors[1].name);
                
                keep = neighbors.shift();
                print("aaa",keep.name);
            }
            if($stations[current.name].nexts.indexOf(prevNode) == 2){
                print(neighbors[0].name,neighbors[1].name);
                keep = neighbors.shift();       
                print("bbb",keep.name);
            }
        }
        var count=neighbors.length;
        for (var neighbor of neighbors) {
            var s=new Searcher{current:neighbor,from ,lineName, owner, path:path.clone(),prevNode:current.name};
            var allPaths=[];
            s.on("result") \(paths) {
                allPaths=allPaths.concat(paths);
                count--;
                if (count==0) {
                    report(allPaths);
                }
            };
        }
        
        path.die();
        alpha=128;
        break;
    }
    updateEx(5);
}
\report(paths) {
    fireEvent("result",paths);
    die();
}
